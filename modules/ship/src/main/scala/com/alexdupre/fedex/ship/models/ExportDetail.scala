package com.alexdupre.fedex.ship.models

import io.circe.syntax.*
import io.circe.{Decoder, Encoder, HCursor, JsonObject}

/** These are export Detail used for US or CA exports.
  *
  * @param b13AFilingOption
  *   Specify the filing option being exercised. Required for non-document shipments originating in Canada destinated for any country other
  *   than Canada, the United States, Puerto Rico, or the U.S. Virgin Islands.
  * @param exportComplianceStatement
  *   For US export shipments requiring an EEI, enter the ITN number received from AES when you filed your shipment or the FTR (Foreign
  *   Trade Regulations) exemption number.The proper format for an ITN number is AES XYYYYMMDDNNNNNN where YYYYMMDD is date and NNNNNN are
  *   numbers generated by the AES.<br> Example: AESX20220714987654<br>Note: The ITN or FTR exemption number you submit in the ship request
  *   prints on the international shipping label.<br><br>For CA export shipments,it can be Proof of report number(15-32 alphanumeric) ,
  *   Summary proof of report number(7-32 alphanumeric) or Exemption number(2 digit) based on the selected b13AFilingOption.<br>Example:
  *   98765432107654321(POR number), 7654321(Summary POR number) and 02(Exemption number). <br>For FTR exemption number you need provide a
  *   predefined value as NO_EEI_30_37_A.
  * @param permitNumber
  *   This is a Permit Number. This field is applicable only to Canada export non-document shipments of any value to any destination. No
  *   special characters are allowed.<br> Example: 12345
  */
case class ExportDetail(
    destinationControlDetail: Option[DestinationControlDetail] = None,
    b13AFilingOption: Option[ExportDetail.B13AFilingOption] = None,
    exportComplianceStatement: Option[String] = None,
    permitNumber: Option[String] = None
)

object ExportDetail {
  enum B13AFilingOption {
    case NOT_REQUIRED
    case MANUALLY_ATTACHED
    case FILED_ELECTRONICALLY
    case SUMMARY_REPORTING
    case FEDEX_TO_STAMP
  }
  object B13AFilingOption {
    given Encoder[B13AFilingOption] = Encoder.encodeString.contramap(_.toString)
    given Decoder[B13AFilingOption] = Decoder.decodeString.emapTry(s => scala.util.Try(B13AFilingOption.valueOf(s)))
  }
  given Encoder[ExportDetail] = new Encoder.AsObject[ExportDetail] {
    final def encodeObject(o: ExportDetail): JsonObject = {
      JsonObject.fromIterable(
        Vector(
          "destinationControlDetail"  -> o.destinationControlDetail.asJson,
          "b13AFilingOption"          -> o.b13AFilingOption.asJson,
          "exportComplianceStatement" -> o.exportComplianceStatement.asJson,
          "permitNumber"              -> o.permitNumber.asJson
        )
      )
    }
  }.mapJson(_.dropNullValues)
  given Decoder[ExportDetail] = (c: HCursor) => {
    for {
      destinationControlDetail  <- c.downField("destinationControlDetail").as[Option[DestinationControlDetail]]
      b13AFilingOption          <- c.downField("b13AFilingOption").as[Option[B13AFilingOption]]
      exportComplianceStatement <- c.downField("exportComplianceStatement").as[Option[String]]
      permitNumber              <- c.downField("permitNumber").as[Option[String]]
    } yield ExportDetail(destinationControlDetail, b13AFilingOption, exportComplianceStatement, permitNumber)
  }
}
